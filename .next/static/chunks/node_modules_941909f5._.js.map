{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/ab/dev/grhog/GRHOG/node_modules/%40swc/helpers/cjs/_interop_require_default.cjs"],"sourcesContent":["\"use strict\";\n\nfunction _interop_require_default(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n}\nexports._ = _interop_require_default;\n"],"names":[],"mappings":"AAEA,SAAS,yBAAyB,GAAG;IACjC,OAAO,OAAO,IAAI,UAAU,GAAG,MAAM;QAAE,SAAS;IAAI;AACxD;AACA,QAAQ,CAAC,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 19, "column": 0}, "map": {"version":3,"sources":["file:///home/ab/dev/grhog/GRHOG/node_modules/%40swc/helpers/cjs/_interop_require_wildcard.cjs"],"sourcesContent":["\"use strict\";\n\nfunction _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n\n    return (_getRequireWildcardCache = function(nodeInterop) {\n        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) return obj;\n    if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") return { default: obj };\n\n    var cache = _getRequireWildcardCache(nodeInterop);\n\n    if (cache && cache.has(obj)) return cache.get(obj);\n\n    var newObj = { __proto__: null };\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n    for (var key in obj) {\n        if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n            if (desc && (desc.get || desc.set)) Object.defineProperty(newObj, key, desc);\n            else newObj[key] = obj[key];\n        }\n    }\n\n    newObj.default = obj;\n\n    if (cache) cache.set(obj, newObj);\n\n    return newObj;\n}\nexports._ = _interop_require_wildcard;\n"],"names":[],"mappings":"AAEA,SAAS,yBAAyB,WAAW;IACzC,IAAI,OAAO,YAAY,YAAY,OAAO;IAE1C,IAAI,oBAAoB,IAAI;IAC5B,IAAI,mBAAmB,IAAI;IAE3B,OAAO,CAAC,2BAA2B,SAAS,WAAW;QACnD,OAAO,cAAc,mBAAmB;IAC5C,CAAC,EAAE;AACP;AACA,SAAS,0BAA0B,GAAG,EAAE,WAAW;IAC/C,IAAI,CAAC,eAAe,OAAO,IAAI,UAAU,EAAE,OAAO;IAClD,IAAI,QAAQ,QAAQ,OAAO,QAAQ,YAAY,OAAO,QAAQ,YAAY,OAAO;QAAE,SAAS;IAAI;IAEhG,IAAI,QAAQ,yBAAyB;IAErC,IAAI,SAAS,MAAM,GAAG,CAAC,MAAM,OAAO,MAAM,GAAG,CAAC;IAE9C,IAAI,SAAS;QAAE,WAAW;IAAK;IAC/B,IAAI,wBAAwB,OAAO,cAAc,IAAI,OAAO,wBAAwB;IAEpF,IAAK,IAAI,OAAO,IAAK;QACjB,IAAI,QAAQ,aAAa,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK,MAAM;YACrE,IAAI,OAAO,wBAAwB,OAAO,wBAAwB,CAAC,KAAK,OAAO;YAC/E,IAAI,QAAQ,CAAC,KAAK,GAAG,IAAI,KAAK,GAAG,GAAG,OAAO,cAAc,CAAC,QAAQ,KAAK;iBAClE,MAAM,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI;QAC/B;IACJ;IAEA,OAAO,OAAO,GAAG;IAEjB,IAAI,OAAO,MAAM,GAAG,CAAC,KAAK;IAE1B,OAAO;AACX;AACA,QAAQ,CAAC,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 56, "column": 0}, "map": {"version":3,"sources":["file:///home/ab/dev/grhog/GRHOG/node_modules/%40swc/helpers/cjs/_define_property.cjs"],"sourcesContent":["\"use strict\";\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });\n    } else obj[key] = value;\n\n    return obj;\n}\nexports._ = _define_property;\n"],"names":[],"mappings":"AAEA,SAAS,iBAAiB,GAAG,EAAE,GAAG,EAAE,KAAK;IACrC,IAAI,OAAO,KAAK;QACZ,OAAO,cAAc,CAAC,KAAK,KAAK;YAAE,OAAO;YAAO,YAAY;YAAM,cAAc;YAAM,UAAU;QAAK;IACzG,OAAO,GAAG,CAAC,IAAI,GAAG;IAElB,OAAO;AACX;AACA,QAAQ,CAAC,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///home/ab/dev/grhog/GRHOG/node_modules/%40swc/helpers/cjs/_class_private_field_loose_base.cjs"],"sourcesContent":["\"use strict\";\n\nfunction _class_private_field_loose_base(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n        throw new TypeError(\"attempted to use private field on non-instance\");\n    }\n\n    return receiver;\n}\nexports._ = _class_private_field_loose_base;\n"],"names":[],"mappings":"AAEA,SAAS,gCAAgC,QAAQ,EAAE,UAAU;IACzD,IAAI,CAAC,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,aAAa;QAC7D,MAAM,IAAI,UAAU;IACxB;IAEA,OAAO;AACX;AACA,QAAQ,CAAC,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["file:///home/ab/dev/grhog/GRHOG/node_modules/%40swc/helpers/cjs/_class_private_field_loose_key.cjs"],"sourcesContent":["\"use strict\";\n\nvar id = 0;\n\nfunction _class_private_field_loose_key(name) {\n    return \"__private_\" + id++ + \"_\" + name;\n}\nexports._ = _class_private_field_loose_key;\n"],"names":[],"mappings":"AAEA,IAAI,KAAK;AAET,SAAS,+BAA+B,IAAI;IACxC,OAAO,eAAe,OAAO,MAAM;AACvC;AACA,QAAQ,CAAC,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 96, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/browser/build/npm/esm/helpers.js","sources":["file:///home/ab/dev/grhog/GRHOG/node_modules/%40sentry/browser/src/helpers.ts"],"sourcesContent":["import type { Mechanism, WrappedFunction } from '@sentry/core';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  addNonEnumerableProperty,\n  captureException,\n  getLocationHref,\n  getOriginalFunction,\n  GLOBAL_OBJ,\n  markFunctionWrapped,\n  withScope,\n} from '@sentry/core';\n\nexport const WINDOW = GLOBAL_OBJ as typeof GLOBAL_OBJ & Window;\n\nlet ignoreOnError: number = 0;\n\n/**\n * @hidden\n */\nexport function shouldIgnoreOnError(): boolean {\n  return ignoreOnError > 0;\n}\n\n/**\n * @hidden\n */\nexport function ignoreNextOnError(): void {\n  // onerror should trigger before setTimeout\n  ignoreOnError++;\n  setTimeout(() => {\n    ignoreOnError--;\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype WrappableFunction = Function;\n\nexport function wrap<T extends WrappableFunction>(\n  fn: T,\n  options?: {\n    mechanism?: Mechanism;\n  },\n): WrappedFunction<T>;\nexport function wrap<NonFunction>(\n  fn: NonFunction,\n  options?: {\n    mechanism?: Mechanism;\n  },\n): NonFunction;\n/**\n * Instruments the given function and sends an event to Sentry every time the\n * function throws an exception.\n *\n * @param fn A function to wrap. It is generally safe to pass an unbound function, because the returned wrapper always\n * has a correct `this` context.\n * @returns The wrapped function.\n * @hidden\n */\nexport function wrap<T extends WrappableFunction, NonFunction>(\n  fn: T | NonFunction,\n  options: {\n    mechanism?: Mechanism;\n  } = {},\n): NonFunction | WrappedFunction<T> {\n  // for future readers what this does is wrap a function and then create\n  // a bi-directional wrapping between them.\n  //\n  // example: wrapped = wrap(original);\n  //  original.__sentry_wrapped__ -> wrapped\n  //  wrapped.__sentry_original__ -> original\n\n  function isFunction(fn: T | NonFunction): fn is T {\n    return typeof fn === 'function';\n  }\n\n  if (!isFunction(fn)) {\n    return fn;\n  }\n\n  try {\n    // if we're dealing with a function that was previously wrapped, return\n    // the original wrapper.\n    const wrapper = (fn as WrappedFunction<T>).__sentry_wrapped__;\n    if (wrapper) {\n      if (typeof wrapper === 'function') {\n        return wrapper;\n      } else {\n        // If we find that the `__sentry_wrapped__` function is not a function at the time of accessing it, it means\n        // that something messed with it. In that case we want to return the originally passed function.\n        return fn;\n      }\n    }\n\n    // We don't wanna wrap it twice\n    if (getOriginalFunction(fn)) {\n      return fn;\n    }\n  } catch (e) {\n    // Just accessing custom props in some Selenium environments\n    // can cause a \"Permission denied\" exception (see raven-js#495).\n    // Bail on wrapping and return the function as-is (defers to window.onerror).\n    return fn;\n  }\n\n  // Wrap the function itself\n  // It is important that `sentryWrapped` is not an arrow function to preserve the context of `this`\n  const sentryWrapped = function (this: unknown, ...args: unknown[]): unknown {\n    try {\n      // Also wrap arguments that are themselves functions\n      const wrappedArguments = args.map(arg => wrap(arg, options));\n\n      // Attempt to invoke user-land function\n      // NOTE: If you are a Sentry user, and you are seeing this stack frame, it\n      //       means the sentry.javascript SDK caught an error invoking your application code. This\n      //       is expected behavior and NOT indicative of a bug with sentry.javascript.\n      return fn.apply(this, wrappedArguments);\n    } catch (ex) {\n      ignoreNextOnError();\n\n      withScope(scope => {\n        scope.addEventProcessor(event => {\n          if (options.mechanism) {\n            addExceptionTypeValue(event, undefined, undefined);\n            addExceptionMechanism(event, options.mechanism);\n          }\n\n          event.extra = {\n            ...event.extra,\n            arguments: args,\n          };\n\n          return event;\n        });\n\n        captureException(ex);\n      });\n\n      throw ex;\n    }\n  } as unknown as WrappedFunction<T>;\n\n  // Wrap the wrapped function in a proxy, to ensure any other properties of the original function remain available\n  try {\n    for (const property in fn) {\n      if (Object.prototype.hasOwnProperty.call(fn, property)) {\n        sentryWrapped[property as keyof T] = fn[property as keyof T];\n      }\n    }\n  } catch {\n    // Accessing some objects may throw\n    // ref: https://github.com/getsentry/sentry-javascript/issues/1168\n  }\n\n  // Signal that this function has been wrapped/filled already\n  // for both debugging and to prevent it to being wrapped/filled twice\n  markFunctionWrapped(sentryWrapped, fn);\n\n  addNonEnumerableProperty(fn, '__sentry_wrapped__', sentryWrapped);\n\n  // Restore original function name (not all browsers allow that)\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name')!;\n    if (descriptor.configurable) {\n      Object.defineProperty(sentryWrapped, 'name', {\n        get(): string {\n          return fn.name;\n        },\n      });\n    }\n  } catch {\n    // This may throw if e.g. the descriptor does not exist, or a browser does not allow redefining `name`.\n    // to save some bytes we simply try-catch this\n  }\n\n  return sentryWrapped;\n}\n\n/**\n * Get HTTP request data from the current page.\n */\nexport function getHttpRequestData(): { url: string; headers: Record<string, string> } {\n  // grab as much info as exists and add it to the event\n  const url = getLocationHref();\n  const { referrer } = WINDOW.document || {};\n  const { userAgent } = WINDOW.navigator || {};\n\n  const headers = {\n    ...(referrer && { Referer: referrer }),\n    ...(userAgent && { 'User-Agent': userAgent }),\n  };\n  const request = {\n    url,\n    headers,\n  };\n\n  return request;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 264, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/browser/build/npm/esm/debug-build.js","sources":["file:///home/ab/dev/grhog/GRHOG/node_modules/%40sentry/browser/src/debug-build.ts"],"sourcesContent":["declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n"],"names":[],"mappings":"AAEA;;;;CAIA;;;AACO,MAAM,WAAY,GAAiB,OAAA,gBAAA,KAAA,WAAA,IAAA,gBAAA","debugId":null}},
    {"offset": {"line": 278, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/browser/build/npm/esm/tracing/backgroundtab.js","sources":["file:///home/ab/dev/grhog/GRHOG/node_modules/%40sentry/browser/src/tracing/backgroundtab.ts"],"sourcesContent":["import { getActiveSpan, getRootSpan, logger, SPAN_STATUS_ERROR, spanToJSON } from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { WINDOW } from '../helpers';\n\n/**\n * Add a listener that cancels and finishes a transaction when the global\n * document is hidden.\n */\nexport function registerBackgroundTabDetection(): void {\n  if (WINDOW.document) {\n    WINDOW.document.addEventListener('visibilitychange', () => {\n      const activeSpan = getActiveSpan();\n      if (!activeSpan) {\n        return;\n      }\n\n      const rootSpan = getRootSpan(activeSpan);\n\n      if (WINDOW.document.hidden && rootSpan) {\n        const cancelledStatus = 'cancelled';\n\n        const { op, status } = spanToJSON(rootSpan);\n\n        if (DEBUG_BUILD) {\n          logger.log(`[Tracing] Transaction: ${cancelledStatus} -> since tab moved to the background, op: ${op}`);\n        }\n\n        // We should not set status if it is already set, this prevent important statuses like\n        // error or data loss from being overwritten on transaction.\n        if (!status) {\n          rootSpan.setStatus({ code: SPAN_STATUS_ERROR, message: cancelledStatus });\n        }\n\n        rootSpan.setAttribute('sentry.cancellation_reason', 'document.hidden');\n        rootSpan.end();\n      }\n    });\n  } else {\n    DEBUG_BUILD && logger.warn('[Tracing] Could not set up background tab detection due to lack of global document');\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;AAIA;;;CAGA,GACO,SAAS,8BAA8B,GAAS;IACrD,6KAAI,SAAM,CAAC,QAAQ,EAAE;iLACnB,SAAM,CAAC,QAAQ,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,MAAM;YACzD,MAAM,UAAA,iLAAa,gBAAA,AAAa,EAAE;YAClC,IAAI,CAAC,UAAU,EAAE;gBACf;YACR;YAEM,MAAM,QAAS,IAAE,2LAAA,AAAW,EAAC,UAAU,CAAC;YAExC,6KAAI,SAAM,CAAC,QAAQ,CAAC,MAAA,IAAU,QAAQ,EAAE;gBACtC,MAAM,eAAgB,GAAE,WAAW;gBAEnC,MAAM,EAAE,EAAE,EAAE,MAAA,EAAA,iLAAW,aAAA,AAAU,EAAC,QAAQ,CAAC;gBAE3C,IAAI,8LAAW,EAAE;2LACf,SAAM,CAAC,GAAG,CAAC,AAAC,uBAAuB,UAAE,eAAe,EAAC,2CAA2C,IAAK,CAAA,CAAA,KAAH,EAAE;gBACC;gBAEA,sFAAA;gBACA,4DAAA;gBACA,IAAA,CAAA,MAAA,EAAA;oBACA,QAAA,CAAA,SAAA,CAAA;wBAAA,IAAA,+KAAA,oBAAA;wBAAA,OAAA,EAAA,eAAA;oBAAA,CAAA,CAAA;gBACA;gBAEA,QAAA,CAAA,YAAA,CAAA,4BAAA,EAAA,iBAAA,CAAA;gBACA,QAAA,CAAA,GAAA,EAAA;YACA;QACA,CAAA,CAAA;IACA,CAAA,MAAA;wLACA,cAAA,2KAAA,SAAA,CAAA,IAAA,CAAA,oFAAA,CAAA;IACA;AACA","debugId":null}},
    {"offset": {"line": 328, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/browser/build/npm/esm/tracing/linkedTraces.js","sources":["file:///home/ab/dev/grhog/GRHOG/node_modules/%40sentry/browser/src/tracing/linkedTraces.ts"],"sourcesContent":["import type { Client, PropagationContext, Span } from '@sentry/core';\nimport {\n  type SpanContextData,\n  getCurrentScope,\n  getRootSpan,\n  logger,\n  SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE,\n  SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE,\n  SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE,\n  spanToJSON,\n} from '@sentry/core';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { WINDOW } from '../exports';\n\nexport interface PreviousTraceInfo {\n  /**\n   * Span context of the previous trace's local root span\n   */\n  spanContext: SpanContextData;\n\n  /**\n   * Timestamp in seconds when the previous trace was started\n   */\n  startTimestamp: number;\n\n  /**\n   * sample rate of the previous trace\n   */\n  sampleRate: number;\n\n  /**\n   * The sample rand of the previous trace\n   */\n  sampleRand: number;\n}\n\n// 1h in seconds\nexport const PREVIOUS_TRACE_MAX_DURATION = 3600;\n\n// session storage key\nexport const PREVIOUS_TRACE_KEY = 'sentry_previous_trace';\n\nexport const PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE = 'sentry.previous_trace';\n\n/**\n * Takes care of linking traces and applying the (consistent) sampling behavoiour based on the passed options\n * @param options - options for linking traces and consistent trace sampling (@see BrowserTracingOptions)\n * @param client - Sentry client\n */\nexport function linkTraces(\n  client: Client,\n  {\n    linkPreviousTrace,\n    consistentTraceSampling,\n  }: {\n    linkPreviousTrace: 'session-storage' | 'in-memory';\n    consistentTraceSampling: boolean;\n  },\n): void {\n  const useSessionStorage = linkPreviousTrace === 'session-storage';\n\n  let inMemoryPreviousTraceInfo = useSessionStorage ? getPreviousTraceFromSessionStorage() : undefined;\n\n  client.on('spanStart', span => {\n    if (getRootSpan(span) !== span) {\n      return;\n    }\n\n    const oldPropagationContext = getCurrentScope().getPropagationContext();\n    inMemoryPreviousTraceInfo = addPreviousTraceSpanLink(inMemoryPreviousTraceInfo, span, oldPropagationContext);\n\n    if (useSessionStorage) {\n      storePreviousTraceInSessionStorage(inMemoryPreviousTraceInfo);\n    }\n  });\n\n  let isFirstTraceOnPageload = true;\n  if (consistentTraceSampling) {\n    /*\n    When users opt into `consistentTraceSampling`, we need to ensure that we propagate\n    the previous trace's sample rate and rand to the current trace. This is necessary because otherwise, span\n    metric extrapolation is inaccurate, as we'd propagate too high of a sample rate for the subsequent traces.\n\n    So therefore, we pretend that the previous trace was the parent trace of the newly started trace. To do that,\n    we mutate the propagation context of the current trace and set the sample rate and sample rand of the previous trace.\n    Timing-wise, it is fine because it happens before we even sample the root span.\n\n    @see https://github.com/getsentry/sentry-javascript/issues/15754\n    */\n    client.on('beforeSampling', mutableSamplingContextData => {\n      if (!inMemoryPreviousTraceInfo) {\n        return;\n      }\n\n      const scope = getCurrentScope();\n      const currentPropagationContext = scope.getPropagationContext();\n\n      // We do not want to force-continue the sampling decision if we continue a trace\n      // that was started on the backend. Most prominently, this will happen in MPAs where\n      // users hard-navigate between pages. In this case, the sampling decision of a potentially\n      // started trace on the server takes precedence.\n      // Why? We want to prioritize inter-trace consistency over intra-trace consistency.\n      if (isFirstTraceOnPageload && currentPropagationContext.parentSpanId) {\n        isFirstTraceOnPageload = false;\n        return;\n      }\n\n      scope.setPropagationContext({\n        ...currentPropagationContext,\n        dsc: {\n          ...currentPropagationContext.dsc,\n          sample_rate: String(inMemoryPreviousTraceInfo.sampleRate),\n          sampled: String(spanContextSampled(inMemoryPreviousTraceInfo.spanContext)),\n        },\n        sampleRand: inMemoryPreviousTraceInfo.sampleRand,\n      });\n\n      mutableSamplingContextData.parentSampled = spanContextSampled(inMemoryPreviousTraceInfo.spanContext);\n      mutableSamplingContextData.parentSampleRate = inMemoryPreviousTraceInfo.sampleRate;\n\n      mutableSamplingContextData.spanAttributes = {\n        ...mutableSamplingContextData.spanAttributes,\n        [SEMANTIC_ATTRIBUTE_SENTRY_PREVIOUS_TRACE_SAMPLE_RATE]: inMemoryPreviousTraceInfo.sampleRate,\n      };\n    });\n  }\n}\n\n/**\n * Adds a previous_trace span link to the passed span if the passed\n * previousTraceInfo is still valid.\n *\n * @returns the updated previous trace info (based on the current span/trace) to\n * be used on the next call\n */\nexport function addPreviousTraceSpanLink(\n  previousTraceInfo: PreviousTraceInfo | undefined,\n  span: Span,\n  oldPropagationContext: PropagationContext,\n): PreviousTraceInfo {\n  const spanJson = spanToJSON(span);\n\n  function getSampleRate(): number {\n    try {\n      return (\n        Number(oldPropagationContext.dsc?.sample_rate) ?? Number(spanJson.data?.[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE])\n      );\n    } catch {\n      return 0;\n    }\n  }\n\n  const updatedPreviousTraceInfo = {\n    spanContext: span.spanContext(),\n    startTimestamp: spanJson.start_timestamp,\n    sampleRate: getSampleRate(),\n    sampleRand: oldPropagationContext.sampleRand,\n  };\n\n  if (!previousTraceInfo) {\n    return updatedPreviousTraceInfo;\n  }\n\n  const previousTraceSpanCtx = previousTraceInfo.spanContext;\n  if (previousTraceSpanCtx.traceId === spanJson.trace_id) {\n    // This means, we're still in the same trace so let's not update the previous trace info\n    // or add a link to the current span.\n    // Once we move away from the long-lived, route-based trace model, we can remove this cases\n    return previousTraceInfo;\n  }\n\n  // Only add the link if the startTimeStamp of the previous trace's root span is within\n  // PREVIOUS_TRACE_MAX_DURATION (1h) of the current root span's startTimestamp\n  // This is done to\n  // - avoid adding links to \"stale\" traces\n  // - enable more efficient querying for previous/next traces in Sentry\n  if (Date.now() / 1000 - previousTraceInfo.startTimestamp <= PREVIOUS_TRACE_MAX_DURATION) {\n    if (DEBUG_BUILD) {\n      logger.info(\n        `Adding previous_trace ${previousTraceSpanCtx} link to span ${{\n          op: spanJson.op,\n          ...span.spanContext(),\n        }}`,\n      );\n    }\n\n    span.addLink({\n      context: previousTraceSpanCtx,\n      attributes: {\n        [SEMANTIC_LINK_ATTRIBUTE_LINK_TYPE]: 'previous_trace',\n      },\n    });\n\n    // TODO: Remove this once EAP can store span links. We currently only set this attribute so that we\n    // can obtain the previous trace information from the EAP store. Long-term, EAP will handle\n    // span links and then we should remove this again. Also throwing in a TODO(v10), to remind us\n    // to check this at v10 time :)\n    span.setAttribute(\n      PREVIOUS_TRACE_TMP_SPAN_ATTRIBUTE,\n      `${previousTraceSpanCtx.traceId}-${previousTraceSpanCtx.spanId}-${\n        spanContextSampled(previousTraceSpanCtx) ? 1 : 0\n      }`,\n    );\n  }\n\n  return updatedPreviousTraceInfo;\n}\n\n/**\n * Stores @param previousTraceInfo in sessionStorage.\n */\nexport function storePreviousTraceInSessionStorage(previousTraceInfo: PreviousTraceInfo): void {\n  try {\n    WINDOW.sessionStorage.setItem(PREVIOUS_TRACE_KEY, JSON.stringify(previousTraceInfo));\n  } catch (e) {\n    // Ignore potential errors (e.g. if sessionStorage is not available)\n    DEBUG_BUILD && logger.warn('Could not store previous trace in sessionStorage', e);\n  }\n}\n\n/**\n * Retrieves the previous trace from sessionStorage if available.\n */\nexport function getPreviousTraceFromSessionStorage(): PreviousTraceInfo | undefined {\n  try {\n    const previousTraceInfo = WINDOW.sessionStorage?.getItem(PREVIOUS_TRACE_KEY);\n    // @ts-expect-error - intentionally risking JSON.parse throwing when previousTraceInfo is null to save bundle size\n    return JSON.parse(previousTraceInfo);\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\n * see {@link import('@sentry/core').spanIsSampled}\n */\nexport function spanContextSampled(ctx: SpanContextData): boolean {\n  return ctx.traceFlags === 0x1;\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA,gBAAA;AACO,MAAM,2BAA4B,GAAE;AAE3C,sBAAA;AACO,MAAM,kBAAmB,GAAE;AAE3B,MAAM,iCAAkC,GAAE;AAEjD;;;;CAIA,GACO,SAAS,UAAU,CACxB,MAAM,OAIR;QAHE,EACE,iBAAiB,EACjB,uBAAuB,EAC3B;IAKE,MAAM,iBAAA,GAAoB,iBAAA,KAAsB,iBAAiB;IAEjE,IAAI,4BAA4B,iBAAA,GAAoB,kCAAkC,EAAG,GAAE,SAAS;IAEpG,MAAM,CAAC,EAAE,CAAC,WAAW,GAAE,QAAQ;QAC7B,IAAI,4LAAA,AAAW,EAAC,IAAI,CAAE,KAAI,IAAI,EAAE;YAC9B;QACN;QAEI,MAAM,wBAAwB,2LAAA,AAAe,EAAE,EAAC,qBAAqB,EAAE;QACvE,yBAAA,GAA4B,wBAAwB,CAAC,yBAAyB,EAAE,IAAI,EAAE,qBAAqB,CAAC;QAE5G,IAAI,iBAAiB,EAAE;YACrB,kCAAkC,CAAC,yBAAyB,CAAC;QACnE;IACA,CAAG,CAAC;IAEF,IAAI,sBAAuB,GAAE,IAAI;IACjC,IAAI,uBAAuB,EAAE;QAC/B;;;;;;;;;;IAUA,GACI,MAAM,CAAC,EAAE,CAAC,gBAAgB,GAAE,8BAA8B;YACxD,IAAI,CAAC,yBAAyB,EAAE;gBAC9B;YACR;YAEM,MAAM,KAAA,OAAQ,uLAAe,AAAf,EAAiB;YAC/B,MAAM,yBAA0B,GAAE,KAAK,CAAC,qBAAqB,EAAE;YAErE,gFAAA;YACA,oFAAA;YACA,0FAAA;YACA,gDAAA;YACA,mFAAA;YACM,IAAI,sBAAA,IAA0B,yBAAyB,CAAC,YAAY,EAAE;gBACpE,sBAAA,GAAyB,KAAK;gBAC9B;YACR;YAEM,KAAK,CAAC,qBAAqB,CAAC;gBAC1B,GAAG,yBAAyB;gBAC5B,GAAG,EAAE;oBACH,GAAG,yBAAyB,CAAC,GAAG;oBAChC,WAAW,EAAE,MAAM,CAAC,yBAAyB,CAAC,UAAU,CAAC;oBACzD,OAAO,EAAE,MAAM,CAAC,kBAAkB,CAAC,yBAAyB,CAAC,WAAW,CAAC,CAAC;gBACpF,CAAS;gBACD,UAAU,EAAE,yBAAyB,CAAC,UAAU;YACxD,CAAO,CAAC;YAEF,0BAA0B,CAAC,aAAc,GAAE,kBAAkB,CAAC,yBAAyB,CAAC,WAAW,CAAC;YACpG,0BAA0B,CAAC,gBAAA,GAAmB,yBAAyB,CAAC,UAAU;YAElF,0BAA0B,CAAC,cAAA,GAAiB;gBAC1C,GAAG,0BAA0B,CAAC,cAAc;gBAC5C,2KAAC,uDAAoD,CAAA,EAAG,yBAAyB,CAAC,UAAU;YACpG,CAAO;QACP,CAAK,CAAC;IACN;AACA;AAEA;;;;;;CAMA,GACO,SAAS,wBAAwB,CACtC,iBAAiB,EACjB,IAAI,EACJ,qBAAqB;IAErB,MAAM,QAAS,IAAE,0LAAA,AAAU,EAAC,IAAI,CAAC;IAEjC,SAAS,aAAa,GAAW;QAC/B,IAAI;4CAEyD,QAAQ;;YADnE,6EAC+B,GAAG,+DAAzB,qBAAqB,MAAM,WAAW,CAAA,mCAA7C,MAAM,IAA4C,MAAM,4BAAU,IAAI,iEAAA,2KAAG,wCAAqC,CAAC;QAEvH,EAAM,UAAM;YACN,OAAO,CAAC;QACd;IACA;IAEE,MAAM,2BAA2B;QAC/B,WAAW,EAAE,IAAI,CAAC,WAAW,EAAE;QAC/B,cAAc,EAAE,QAAQ,CAAC,eAAe;QACxC,UAAU,EAAE,aAAa,EAAE;QAC3B,UAAU,EAAE,qBAAqB,CAAC,UAAU;IAChD,CAAG;IAED,IAAI,CAAC,iBAAiB,EAAE;QACtB,OAAO,wBAAwB;IACnC;IAEE,MAAM,oBAAA,GAAuB,iBAAiB,CAAC,WAAW;IAC1D,IAAI,oBAAoB,CAAC,OAAA,KAAY,QAAQ,CAAC,QAAQ,EAAE;QAC1D,wFAAA;QACA,qCAAA;QACA,2FAAA;QACI,OAAO,iBAAiB;IAC5B;IAEA,sFAAA;IACA,6EAAA;IACA,kBAAA;IACA,yCAAA;IACA,sEAAA;IACE,IAAI,IAAI,CAAC,GAAG,EAAC,GAAI,IAAA,GAAO,iBAAiB,CAAC,cAAe,IAAG,2BAA2B,EAAE;QACvF,oLAAI,cAAW,EAAE;mLACf,SAAM,CAAC,IAAI,CACT,AAAC,sBAAsB,UAAE,oBAAoB,EAAC,cAAc,IAG1D,CAAA,MAH4D;gBAC5D,EAAE,EAAE,QAAQ,CAAC,EAAE;gBACf,GAAG,IAAI,CAAC,WAAW,EAAE;YAC/B,CAAS;QAEC;QAEA,IAAA,CAAA,OAAA,CAAA;YACA,OAAA,EAAA,oBAAA;YACA,UAAA,EAAA;gBACA,0KAAA,qCAAA,CAAA,EAAA,gBAAA;YACA,CAAA;QACA,CAAA,CAAA;QAEA,mGAAA;QACA,2FAAA;QACA,8FAAA;QACA,+BAAA;QACA,IAAA,CAAA,YAAA,CACA,iCAAA,EACA,UAAA,oBAAA,CAAA,OAAA,EAAA,CAAA,IACA,OADA,WACA,SADA,CAAA,MAAA,EAAA,CAAA,IAEA,CAAA,yBADA,oBAAA,CAAA,GAAA,CAAA,GAAA;IAGA;IAEA,OAAA,wBAAA;AACA;AAEA;;CAEA,GACA,SAAA,kCAAA,CAAA,iBAAA,EAAA;IACA,IAAA;iLACA,SAAA,CAAA,cAAA,CAAA,OAAA,CAAA,kBAAA,EAAA,IAAA,CAAA,SAAA,CAAA,iBAAA,CAAA,CAAA;IACA,CAAA,CAAA,OAAA,CAAA,EAAA;QACA,oEAAA;wLACA,cAAA,2KAAA,SAAA,CAAA,IAAA,CAAA,kDAAA,EAAA,CAAA,CAAA;IACA;AACA;AAEA;;CAEA,GACA,SAAA,kCAAA,GAAA;IACA,IAAA;;QACA,MAAA,iBAAA,+MAAA,CAAA,cAAA,2DAAA,uBAAA,OAAA,CAAA,kBAAA,CAAA;QACA,kHAAA;QACA,OAAA,IAAA,CAAA,KAAA,CAAA,iBAAA,CAAA;IACA,CAAA,CAAA,OAAA,CAAA,EAAA;QACA,OAAA,SAAA;IACA;AACA;AAEA;;CAEA,GACA,SAAA,kBAAA,CAAA,GAAA,EAAA;IACA,OAAA,GAAA,CAAA,UAAA,KAAA,GAAA;AACA","debugId":null}},
    {"offset": {"line": 515, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/browser/build/npm/esm/tracing/request.js","sources":["file:///home/ab/dev/grhog/GRHOG/node_modules/%40sentry/browser/src/tracing/request.ts"],"sourcesContent":["import type { Client, HandlerDataXhr, SentryWrappedXMLHttpRequest, Span, WebFetchHeaders } from '@sentry/core';\nimport {\n  addFetchEndInstrumentationHandler,\n  addFetchInstrumentationHandler,\n  browserPerformanceTimeOrigin,\n  getActiveSpan,\n  getClient,\n  getLocationHref,\n  getTraceData,\n  hasSpansEnabled,\n  instrumentFetchRequest,\n  parseUrl,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SentryNonRecordingSpan,\n  setHttpStatus,\n  spanToJSON,\n  startInactiveSpan,\n  stringMatchesSomePattern,\n  stripUrlQueryAndFragment,\n} from '@sentry/core';\nimport type { XhrHint } from '@sentry-internal/browser-utils';\nimport {\n  addPerformanceInstrumentationHandler,\n  addXhrInstrumentationHandler,\n  extractNetworkProtocol,\n  SENTRY_XHR_DATA_KEY,\n} from '@sentry-internal/browser-utils';\nimport { WINDOW } from '../helpers';\n\n/** Options for Request Instrumentation */\nexport interface RequestInstrumentationOptions {\n  /**\n   * List of strings and/or Regular Expressions used to determine which outgoing requests will have `sentry-trace` and `baggage`\n   * headers attached.\n   *\n   * **Default:** If this option is not provided, tracing headers will be attached to all outgoing requests.\n   * If you are using a browser SDK, by default, tracing headers will only be attached to outgoing requests to the same origin.\n   *\n   * **Disclaimer:** Carelessly setting this option in browser environments may result into CORS errors!\n   * Only attach tracing headers to requests to the same origin, or to requests to services you can control CORS headers of.\n   * Cross-origin requests, meaning requests to a different domain, for example a request to `https://api.example.com/` while you're on `https://example.com/`, take special care.\n   * If you are attaching headers to cross-origin requests, make sure the backend handling the request returns a `\"Access-Control-Allow-Headers: sentry-trace, baggage\"` header to ensure your requests aren't blocked.\n   *\n   * If you provide a `tracePropagationTargets` array, the entries you provide will be matched against the entire URL of the outgoing request.\n   * If you are using a browser SDK, the entries will also be matched against the pathname of the outgoing requests.\n   * This is so you can have matchers for relative requests, for example, `/^\\/api/` if you want to trace requests to your `/api` routes on the same domain.\n   *\n   * If any of the two match any of the provided values, tracing headers will be attached to the outgoing request.\n   * Both, the string values, and the RegExes you provide in the array will match if they partially match the URL or pathname.\n   *\n   * Examples:\n   * - `tracePropagationTargets: [/^\\/api/]` and request to `https://same-origin.com/api/posts`:\n   *   - Tracing headers will be attached because the request is sent to the same origin and the regex matches the pathname \"/api/posts\".\n   * - `tracePropagationTargets: [/^\\/api/]` and request to `https://different-origin.com/api/posts`:\n   *   - Tracing headers will not be attached because the pathname will only be compared when the request target lives on the same origin.\n   * - `tracePropagationTargets: [/^\\/api/, 'https://external-api.com']` and request to `https://external-api.com/v1/data`:\n   *   - Tracing headers will be attached because the request URL matches the string `'https://external-api.com'`.\n   */\n  tracePropagationTargets?: Array<string | RegExp>;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * Flag to disable tracking of long-lived streams, like server-sent events (SSE) via fetch.\n   * Do not enable this in case you have live streams or very long running streams.\n   *\n   * Disabled by default since it can lead to issues with streams using the `cancel()` api\n   * (https://github.com/getsentry/sentry-javascript/issues/13950)\n   *\n   * Default: false\n   */\n  trackFetchStreamPerformance: boolean;\n\n  /**\n   * If true, Sentry will capture http timings and add them to the corresponding http spans.\n   *\n   * Default: true\n   */\n  enableHTTPTimings: boolean;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n\n  /**\n   * Is called when spans are started for outgoing requests.\n   */\n  onRequestSpanStart?(span: Span, requestInformation: { headers?: WebFetchHeaders }): void;\n}\n\nconst responseToSpanId = new WeakMap<object, string>();\nconst spanIdToEndTimestamp = new Map<string, number>();\n\nexport const defaultRequestInstrumentationOptions: RequestInstrumentationOptions = {\n  traceFetch: true,\n  traceXHR: true,\n  enableHTTPTimings: true,\n  trackFetchStreamPerformance: false,\n};\n\n/** Registers span creators for xhr and fetch requests  */\nexport function instrumentOutgoingRequests(client: Client, _options?: Partial<RequestInstrumentationOptions>): void {\n  const {\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    tracePropagationTargets,\n    onRequestSpanStart,\n  } = {\n    ...defaultRequestInstrumentationOptions,\n    ..._options,\n  };\n\n  const shouldCreateSpan =\n    typeof shouldCreateSpanForRequest === 'function' ? shouldCreateSpanForRequest : (_: string) => true;\n\n  const shouldAttachHeadersWithTargets = (url: string): boolean => shouldAttachHeaders(url, tracePropagationTargets);\n\n  const spans: Record<string, Span> = {};\n\n  if (traceFetch) {\n    // Keeping track of http requests, whose body payloads resolved later than the initial resolved request\n    // e.g. streaming using server sent events (SSE)\n    client.addEventProcessor(event => {\n      if (event.type === 'transaction' && event.spans) {\n        event.spans.forEach(span => {\n          if (span.op === 'http.client') {\n            const updatedTimestamp = spanIdToEndTimestamp.get(span.span_id);\n            if (updatedTimestamp) {\n              span.timestamp = updatedTimestamp / 1000;\n              spanIdToEndTimestamp.delete(span.span_id);\n            }\n          }\n        });\n      }\n      return event;\n    });\n\n    if (trackFetchStreamPerformance) {\n      addFetchEndInstrumentationHandler(handlerData => {\n        if (handlerData.response) {\n          const span = responseToSpanId.get(handlerData.response);\n          if (span && handlerData.endTimestamp) {\n            spanIdToEndTimestamp.set(span, handlerData.endTimestamp);\n          }\n        }\n      });\n    }\n\n    addFetchInstrumentationHandler(handlerData => {\n      const createdSpan = instrumentFetchRequest(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n\n      if (handlerData.response && handlerData.fetchData.__span) {\n        responseToSpanId.set(handlerData.response, handlerData.fetchData.__span);\n      }\n\n      // We cannot use `window.location` in the generic fetch instrumentation,\n      // but we need it for reliable `server.address` attribute.\n      // so we extend this in here\n      if (createdSpan) {\n        const fullUrl = getFullURL(handlerData.fetchData.url);\n        const host = fullUrl ? parseUrl(fullUrl).host : undefined;\n        createdSpan.setAttributes({\n          'http.url': fullUrl,\n          'server.address': host,\n        });\n\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n\n        onRequestSpanStart?.(createdSpan, { headers: handlerData.headers });\n      }\n    });\n  }\n\n  if (traceXHR) {\n    addXhrInstrumentationHandler(handlerData => {\n      const createdSpan = xhrCallback(handlerData, shouldCreateSpan, shouldAttachHeadersWithTargets, spans);\n      if (createdSpan) {\n        if (enableHTTPTimings) {\n          addHTTPTimings(createdSpan);\n        }\n\n        let headers;\n        try {\n          headers = new Headers(handlerData.xhr.__sentry_xhr_v3__?.request_headers);\n        } catch {\n          // noop\n        }\n        onRequestSpanStart?.(createdSpan, { headers });\n      }\n    });\n  }\n}\n\nfunction isPerformanceResourceTiming(entry: PerformanceEntry): entry is PerformanceResourceTiming {\n  return (\n    entry.entryType === 'resource' &&\n    'initiatorType' in entry &&\n    typeof (entry as PerformanceResourceTiming).nextHopProtocol === 'string' &&\n    (entry.initiatorType === 'fetch' || entry.initiatorType === 'xmlhttprequest')\n  );\n}\n\n/**\n * Creates a temporary observer to listen to the next fetch/xhr resourcing timings,\n * so that when timings hit their per-browser limit they don't need to be removed.\n *\n * @param span A span that has yet to be finished, must contain `url` on data.\n */\nfunction addHTTPTimings(span: Span): void {\n  const { url } = spanToJSON(span).data;\n\n  if (!url || typeof url !== 'string') {\n    return;\n  }\n\n  const cleanup = addPerformanceInstrumentationHandler('resource', ({ entries }) => {\n    entries.forEach(entry => {\n      if (isPerformanceResourceTiming(entry) && entry.name.endsWith(url)) {\n        const spanData = resourceTimingEntryToSpanData(entry);\n        spanData.forEach(data => span.setAttribute(...data));\n        // In the next tick, clean this handler up\n        // We have to wait here because otherwise this cleans itself up before it is fully done\n        setTimeout(cleanup);\n      }\n    });\n  });\n}\n\nfunction getAbsoluteTime(time: number = 0): number {\n  return ((browserPerformanceTimeOrigin() || performance.timeOrigin) + time) / 1000;\n}\n\nfunction resourceTimingEntryToSpanData(resourceTiming: PerformanceResourceTiming): [string, string | number][] {\n  const { name, version } = extractNetworkProtocol(resourceTiming.nextHopProtocol);\n\n  const timingSpanData: [string, string | number][] = [];\n\n  timingSpanData.push(['network.protocol.version', version], ['network.protocol.name', name]);\n\n  if (!browserPerformanceTimeOrigin()) {\n    return timingSpanData;\n  }\n  return [\n    ...timingSpanData,\n    ['http.request.redirect_start', getAbsoluteTime(resourceTiming.redirectStart)],\n    ['http.request.fetch_start', getAbsoluteTime(resourceTiming.fetchStart)],\n    ['http.request.domain_lookup_start', getAbsoluteTime(resourceTiming.domainLookupStart)],\n    ['http.request.domain_lookup_end', getAbsoluteTime(resourceTiming.domainLookupEnd)],\n    ['http.request.connect_start', getAbsoluteTime(resourceTiming.connectStart)],\n    ['http.request.secure_connection_start', getAbsoluteTime(resourceTiming.secureConnectionStart)],\n    ['http.request.connection_end', getAbsoluteTime(resourceTiming.connectEnd)],\n    ['http.request.request_start', getAbsoluteTime(resourceTiming.requestStart)],\n    ['http.request.response_start', getAbsoluteTime(resourceTiming.responseStart)],\n    ['http.request.response_end', getAbsoluteTime(resourceTiming.responseEnd)],\n  ];\n}\n\n/**\n * A function that determines whether to attach tracing headers to a request.\n * We only export this function for testing purposes.\n */\nexport function shouldAttachHeaders(\n  targetUrl: string,\n  tracePropagationTargets: (string | RegExp)[] | undefined,\n): boolean {\n  // window.location.href not being defined is an edge case in the browser but we need to handle it.\n  // Potentially dangerous situations where it may not be defined: Browser Extensions, Web Workers, patching of the location obj\n  const href = getLocationHref();\n\n  if (!href) {\n    // If there is no window.location.origin, we default to only attaching tracing headers to relative requests, i.e. ones that start with `/`\n    // BIG DISCLAIMER: Users can call URLs with a double slash (fetch(\"//example.com/api\")), this is a shorthand for \"send to the same protocol\",\n    // so we need a to exclude those requests, because they might be cross origin.\n    const isRelativeSameOriginRequest = !!targetUrl.match(/^\\/(?!\\/)/);\n    if (!tracePropagationTargets) {\n      return isRelativeSameOriginRequest;\n    } else {\n      return stringMatchesSomePattern(targetUrl, tracePropagationTargets);\n    }\n  } else {\n    let resolvedUrl;\n    let currentOrigin;\n\n    // URL parsing may fail, we default to not attaching trace headers in that case.\n    try {\n      resolvedUrl = new URL(targetUrl, href);\n      currentOrigin = new URL(href).origin;\n    } catch (e) {\n      return false;\n    }\n\n    const isSameOriginRequest = resolvedUrl.origin === currentOrigin;\n    if (!tracePropagationTargets) {\n      return isSameOriginRequest;\n    } else {\n      return (\n        stringMatchesSomePattern(resolvedUrl.toString(), tracePropagationTargets) ||\n        (isSameOriginRequest && stringMatchesSomePattern(resolvedUrl.pathname, tracePropagationTargets))\n      );\n    }\n  }\n}\n\n/**\n * Create and track xhr request spans\n *\n * @returns Span if a span was created, otherwise void.\n */\nexport function xhrCallback(\n  handlerData: HandlerDataXhr,\n  shouldCreateSpan: (url: string) => boolean,\n  shouldAttachHeaders: (url: string) => boolean,\n  spans: Record<string, Span>,\n): Span | undefined {\n  const xhr = handlerData.xhr;\n  const sentryXhrData = xhr?.[SENTRY_XHR_DATA_KEY];\n\n  if (!xhr || xhr.__sentry_own_request__ || !sentryXhrData) {\n    return undefined;\n  }\n\n  const { url, method } = sentryXhrData;\n\n  const shouldCreateSpanResult = hasSpansEnabled() && shouldCreateSpan(url);\n\n  // check first if the request has finished and is tracked by an existing span which should now end\n  if (handlerData.endTimestamp && shouldCreateSpanResult) {\n    const spanId = xhr.__sentry_xhr_span_id__;\n    if (!spanId) return;\n\n    const span = spans[spanId];\n    if (span && sentryXhrData.status_code !== undefined) {\n      setHttpStatus(span, sentryXhrData.status_code);\n      span.end();\n\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete spans[spanId];\n    }\n    return undefined;\n  }\n\n  const fullUrl = getFullURL(url);\n  const parsedUrl = fullUrl ? parseUrl(fullUrl) : parseUrl(url);\n\n  const urlForSpanName = stripUrlQueryAndFragment(url);\n\n  const hasParent = !!getActiveSpan();\n\n  const span =\n    shouldCreateSpanResult && hasParent\n      ? startInactiveSpan({\n          name: `${method} ${urlForSpanName}`,\n          attributes: {\n            url,\n            type: 'xhr',\n            'http.method': method,\n            'http.url': fullUrl,\n            'server.address': parsedUrl?.host,\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.browser',\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.client',\n            ...(parsedUrl?.search && { 'http.query': parsedUrl?.search }),\n            ...(parsedUrl?.hash && { 'http.fragment': parsedUrl?.hash }),\n          },\n        })\n      : new SentryNonRecordingSpan();\n\n  xhr.__sentry_xhr_span_id__ = span.spanContext().spanId;\n  spans[xhr.__sentry_xhr_span_id__] = span;\n\n  if (shouldAttachHeaders(url)) {\n    addTracingHeadersToXhrRequest(\n      xhr,\n      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),\n      // we do not want to use the span as base for the trace headers,\n      // which means that the headers will be generated from the scope and the sampling decision is deferred\n      hasSpansEnabled() && hasParent ? span : undefined,\n    );\n  }\n\n  const client = getClient();\n  if (client) {\n    client.emit('beforeOutgoingRequestSpan', span, handlerData as XhrHint);\n  }\n\n  return span;\n}\n\nfunction addTracingHeadersToXhrRequest(xhr: SentryWrappedXMLHttpRequest, span?: Span): void {\n  const { 'sentry-trace': sentryTrace, baggage } = getTraceData({ span });\n\n  if (sentryTrace) {\n    setHeaderOnXhr(xhr, sentryTrace, baggage);\n  }\n}\n\nfunction setHeaderOnXhr(\n  xhr: SentryWrappedXMLHttpRequest,\n  sentryTraceHeader: string,\n  sentryBaggageHeader: string | undefined,\n): void {\n  const originalHeaders = xhr.__sentry_xhr_v3__?.request_headers;\n\n  if (originalHeaders?.['sentry-trace']) {\n    // bail if a sentry-trace header is already set\n    return;\n  }\n\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    xhr.setRequestHeader!('sentry-trace', sentryTraceHeader);\n    if (sentryBaggageHeader) {\n      // only add our headers if\n      // - no pre-existing baggage header exists\n      // - or it is set and doesn't yet contain sentry values\n      const originalBaggageHeader = originalHeaders?.['baggage'];\n      if (!originalBaggageHeader || !baggageHeaderHasSentryValues(originalBaggageHeader)) {\n        // From MDN: \"If this method is called several times with the same header, the values are merged into one single request header.\"\n        // We can therefore simply set a baggage header without checking what was there before\n        // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        xhr.setRequestHeader!('baggage', sentryBaggageHeader);\n      }\n    }\n  } catch (_) {\n    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.\n  }\n}\n\nfunction baggageHeaderHasSentryValues(baggageHeader: string): boolean {\n  return baggageHeader.split(',').some(value => value.trim().startsWith('sentry-'));\n}\n\nfunction getFullURL(url: string): string | undefined {\n  try {\n    // By adding a base URL to new URL(), this will also work for relative urls\n    // If `url` is a full URL, the base URL is ignored anyhow\n    const parsed = new URL(url, WINDOW.location.origin);\n    return parsed.href;\n  } catch {\n    return undefined;\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 867, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/browser/build/npm/esm/tracing/browserTracingIntegration.js","sources":["file:///home/ab/dev/grhog/GRHOG/node_modules/%40sentry/browser/src/tracing/browserTracingIntegration.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { Client, IntegrationFn, Span, StartSpanOptions, TransactionSource, WebFetchHeaders } from '@sentry/core';\nimport {\n  addNonEnumerableProperty,\n  browserPerformanceTimeOrigin,\n  generateTraceId,\n  getClient,\n  getCurrentScope,\n  getDynamicSamplingContextFromSpan,\n  getIsolationScope,\n  getLocationHref,\n  GLOBAL_OBJ,\n  logger,\n  parseStringToURLObject,\n  propagationContextFromHeaders,\n  registerSpanErrorInstrumentation,\n  SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  spanIsSampled,\n  spanToJSON,\n  startIdleSpan,\n  TRACING_DEFAULTS,\n} from '@sentry/core';\nimport {\n  addHistoryInstrumentationHandler,\n  addPerformanceEntries,\n  registerInpInteractionListener,\n  startTrackingINP,\n  startTrackingInteractions,\n  startTrackingLongAnimationFrames,\n  startTrackingLongTasks,\n  startTrackingWebVitals,\n} from '@sentry-internal/browser-utils';\nimport { DEBUG_BUILD } from '../debug-build';\nimport { getHttpRequestData, WINDOW } from '../helpers';\nimport { registerBackgroundTabDetection } from './backgroundtab';\nimport { linkTraces } from './linkedTraces';\nimport { defaultRequestInstrumentationOptions, instrumentOutgoingRequests } from './request';\n\nexport const BROWSER_TRACING_INTEGRATION_ID = 'BrowserTracing';\n\ninterface RouteInfo {\n  name: string | undefined;\n  source: TransactionSource | undefined;\n}\n\n/** Options for Browser Tracing integration */\nexport interface BrowserTracingOptions {\n  /**\n   * The time that has to pass without any span being created.\n   * If this time is exceeded, the idle span will finish.\n   *\n   * Default: 1000 (ms)\n   */\n  idleTimeout: number;\n\n  /**\n   * The max. time an idle span may run.\n   * If this time is exceeded, the idle span will finish no matter what.\n   *\n   * Default: 30000 (ms)\n   */\n  finalTimeout: number;\n\n  /**\n   The max. time an idle span may run.\n   * If this time is exceeded, the idle span will finish no matter what.\n   *\n   * Default: 15000 (ms)\n   */\n  childSpanTimeout: number;\n\n  /**\n   * If a span should be created on page load.\n   * If this is set to `false`, this integration will not start the default page load span.\n   * Default: true\n   */\n  instrumentPageLoad: boolean;\n\n  /**\n   * If a span should be created on navigation (history change).\n   * If this is set to `false`, this integration will not start the default navigation spans.\n   * Default: true\n   */\n  instrumentNavigation: boolean;\n\n  /**\n   * Flag spans where tabs moved to background with \"cancelled\". Browser background tab timing is\n   * not suited towards doing precise measurements of operations. By default, we recommend that this option\n   * be enabled as background transactions can mess up your statistics in nondeterministic ways.\n   *\n   * Default: true\n   */\n  markBackgroundSpan: boolean;\n\n  /**\n   * If true, Sentry will capture long tasks and add them to the corresponding transaction.\n   *\n   * Default: true\n   */\n  enableLongTask: boolean;\n\n  /**\n   * If true, Sentry will capture long animation frames and add them to the corresponding transaction.\n   *\n   * Default: false\n   */\n  enableLongAnimationFrame: boolean;\n\n  /**\n   * If true, Sentry will capture first input delay and add it to the corresponding transaction.\n   *\n   * Default: true\n   */\n  enableInp: boolean;\n\n  /**\n   * Flag to disable patching all together for fetch requests.\n   *\n   * Default: true\n   */\n  traceFetch: boolean;\n\n  /**\n   * Flag to disable patching all together for xhr requests.\n   *\n   * Default: true\n   */\n  traceXHR: boolean;\n\n  /**\n   * Flag to disable tracking of long-lived streams, like server-sent events (SSE) via fetch.\n   * Do not enable this in case you have live streams or very long running streams.\n   *\n   * Default: false\n   */\n  trackFetchStreamPerformance: boolean;\n\n  /**\n   * If true, Sentry will capture http timings and add them to the corresponding http spans.\n   *\n   * Default: true\n   */\n  enableHTTPTimings: boolean;\n\n  /**\n   * Resource spans with `op`s matching strings in the array will not be emitted.\n   *\n   * Default: []\n   */\n  ignoreResourceSpans: Array<'resouce.script' | 'resource.css' | 'resource.img' | 'resource.other' | string>;\n\n  /**\n   * Spans created from the following browser Performance APIs,\n   *\n   * - [`performance.mark(...)`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/mark)\n   * - [`performance.measure(...)`](https://developer.mozilla.org/en-US/docs/Web/API/Performance/measure)\n   *\n   * will not be emitted if their names match strings in this array.\n   *\n   * This is useful, if you come across `mark` or `measure` spans in your Sentry traces\n   * that you want to ignore. For example, sometimes, browser extensions or libraries\n   * emit these entries on their own, which might not be relevant to your application.\n   *\n   * * @example\n   * ```ts\n   * Sentry.init({\n   *   integrations: [\n   *     Sentry.browserTracingIntegration({\n   *      ignorePerformanceApiSpans: ['myMeasurement', /myMark/],\n   *     }),\n   *   ],\n   * });\n   *\n   * // no spans will be created for these:\n   * performance.mark('myMark');\n   * performance.measure('myMeasurement');\n   *\n   * // spans will be created for these:\n   * performance.mark('authenticated');\n   * performance.measure('input-duration', ...);\n   * ```\n   *\n   * Default: [] - By default, all `mark` and `measure` entries are sent as spans.\n   */\n  ignorePerformanceApiSpans: Array<string | RegExp>;\n\n  /**\n   * Link the currently started trace to a previous trace (e.g. a prior pageload, navigation or\n   * manually started span). When enabled, this option will allow you to navigate between traces\n   * in the Sentry UI.\n   *\n   * You can set this option to the following values:\n   *\n   * - `'in-memory'`: The previous trace data will be stored in memory.\n   *   This is useful for single-page applications and enabled by default.\n   *\n   * - `'session-storage'`: The previous trace data will be stored in the `sessionStorage`.\n   *   This is useful for multi-page applications or static sites but it means that the\n   *   Sentry SDK writes to the browser's `sessionStorage`.\n   *\n   * - `'off'`: The previous trace data will not be stored or linked.\n   *\n   * You can also use {@link BrowserTracingOptions.consistentTraceSampling} to get\n   * consistent trace sampling of subsequent traces. Otherwise, by default, your\n   * `tracesSampleRate` or `tracesSampler` config significantly influences how often\n   * traces will be linked.\n   *\n   * @default 'in-memory' - see explanation above\n   */\n  linkPreviousTrace: 'in-memory' | 'session-storage' | 'off';\n\n  /**\n   * If true, Sentry will consistently sample subsequent traces based on the\n   * sampling decision of the initial trace. For example, if the initial page\n   * load trace was sampled positively, all subsequent traces (e.g. navigations)\n   * are also sampled positively. In case the initial trace was sampled negatively,\n   * all subsequent traces are also sampled negatively.\n   *\n   * This option allows you to get consistent, linked traces within a user journey\n   * while maintaining an overall quota based on your trace sampling settings.\n   *\n   * This option is only effective if {@link BrowserTracingOptions.linkPreviousTrace}\n   * is enabled (i.e. not set to `'off'`).\n   *\n   * @default `false` - this is an opt-in feature.\n   */\n  consistentTraceSampling: boolean;\n\n  /**\n   * _experiments allows the user to send options to define how this integration works.\n   *\n   * Default: undefined\n   */\n  _experiments: Partial<{\n    enableInteractions: boolean;\n    enableStandaloneClsSpans: boolean;\n  }>;\n\n  /**\n   * A callback which is called before a span for a pageload or navigation is started.\n   * It receives the options passed to `startSpan`, and expects to return an updated options object.\n   */\n  beforeStartSpan?: (options: StartSpanOptions) => StartSpanOptions;\n\n  /**\n   * This function will be called before creating a span for a request with the given url.\n   * Return false if you don't want a span for the given url.\n   *\n   * Default: (url: string) => true\n   */\n  shouldCreateSpanForRequest?(this: void, url: string): boolean;\n\n  /**\n   * This callback is invoked directly after a span is started for an outgoing fetch or XHR request.\n   * You can use it to annotate the span with additional data or attributes, for example by setting\n   * attributes based on the passed request headers.\n   */\n  onRequestSpanStart?(span: Span, requestInformation: { headers?: WebFetchHeaders }): void;\n}\n\nconst DEFAULT_BROWSER_TRACING_OPTIONS: BrowserTracingOptions = {\n  ...TRACING_DEFAULTS,\n  instrumentNavigation: true,\n  instrumentPageLoad: true,\n  markBackgroundSpan: true,\n  enableLongTask: true,\n  enableLongAnimationFrame: true,\n  enableInp: true,\n  ignoreResourceSpans: [],\n  ignorePerformanceApiSpans: [],\n  linkPreviousTrace: 'in-memory',\n  consistentTraceSampling: false,\n  _experiments: {},\n  ...defaultRequestInstrumentationOptions,\n};\n\n/**\n * The Browser Tracing integration automatically instruments browser pageload/navigation\n * actions as transactions, and captures requests, metrics and errors as spans.\n *\n * The integration can be configured with a variety of options, and can be extended to use\n * any routing library.\n *\n * We explicitly export the proper type here, as this has to be extended in some cases.\n */\nexport const browserTracingIntegration = ((_options: Partial<BrowserTracingOptions> = {}) => {\n  const latestRoute: RouteInfo = {\n    name: undefined,\n    source: undefined,\n  };\n\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document as (typeof WINDOW)['document'] | undefined;\n\n  const {\n    enableInp,\n    enableLongTask,\n    enableLongAnimationFrame,\n    _experiments: { enableInteractions, enableStandaloneClsSpans },\n    beforeStartSpan,\n    idleTimeout,\n    finalTimeout,\n    childSpanTimeout,\n    markBackgroundSpan,\n    traceFetch,\n    traceXHR,\n    trackFetchStreamPerformance,\n    shouldCreateSpanForRequest,\n    enableHTTPTimings,\n    ignoreResourceSpans,\n    ignorePerformanceApiSpans,\n    instrumentPageLoad,\n    instrumentNavigation,\n    linkPreviousTrace,\n    consistentTraceSampling,\n    onRequestSpanStart,\n  } = {\n    ...DEFAULT_BROWSER_TRACING_OPTIONS,\n    ..._options,\n  };\n\n  let _collectWebVitals: undefined | (() => void);\n\n  /** Create routing idle transaction. */\n  function _createRouteSpan(client: Client, startSpanOptions: StartSpanOptions): void {\n    const isPageloadTransaction = startSpanOptions.op === 'pageload';\n\n    const finalStartSpanOptions: StartSpanOptions = beforeStartSpan\n      ? beforeStartSpan(startSpanOptions)\n      : startSpanOptions;\n\n    const attributes = finalStartSpanOptions.attributes || {};\n\n    // If `finalStartSpanOptions.name` is different than `startSpanOptions.name`\n    // it is because `beforeStartSpan` set a custom name. Therefore we set the source to 'custom'.\n    if (startSpanOptions.name !== finalStartSpanOptions.name) {\n      attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE] = 'custom';\n      finalStartSpanOptions.attributes = attributes;\n    }\n\n    latestRoute.name = finalStartSpanOptions.name;\n    latestRoute.source = attributes[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE];\n\n    const idleSpan = startIdleSpan(finalStartSpanOptions, {\n      idleTimeout,\n      finalTimeout,\n      childSpanTimeout,\n      // should wait for finish signal if it's a pageload transaction\n      disableAutoFinish: isPageloadTransaction,\n      beforeSpanEnd: span => {\n        // This will generally always be defined here, because it is set in `setup()` of the integration\n        // but technically, it is optional, so we guard here to be extra safe\n        _collectWebVitals?.();\n        addPerformanceEntries(span, {\n          recordClsOnPageloadSpan: !enableStandaloneClsSpans,\n          ignoreResourceSpans,\n          ignorePerformanceApiSpans,\n        });\n        setActiveIdleSpan(client, undefined);\n\n        // A trace should stay consistent over the entire timespan of one route - even after the pageload/navigation ended.\n        // Only when another navigation happens, we want to create a new trace.\n        // This way, e.g. errors that occur after the pageload span ended are still associated to the pageload trace.\n        const scope = getCurrentScope();\n        const oldPropagationContext = scope.getPropagationContext();\n\n        scope.setPropagationContext({\n          ...oldPropagationContext,\n          traceId: idleSpan.spanContext().traceId,\n          sampled: spanIsSampled(idleSpan),\n          dsc: getDynamicSamplingContextFromSpan(span),\n        });\n      },\n    });\n\n    setActiveIdleSpan(client, idleSpan);\n\n    function emitFinish(): void {\n      if (optionalWindowDocument && ['interactive', 'complete'].includes(optionalWindowDocument.readyState)) {\n        client.emit('idleSpanEnableAutoFinish', idleSpan);\n      }\n    }\n\n    if (isPageloadTransaction && optionalWindowDocument) {\n      optionalWindowDocument.addEventListener('readystatechange', () => {\n        emitFinish();\n      });\n\n      emitFinish();\n    }\n  }\n\n  return {\n    name: BROWSER_TRACING_INTEGRATION_ID,\n    setup(client) {\n      registerSpanErrorInstrumentation();\n\n      _collectWebVitals = startTrackingWebVitals({ recordClsStandaloneSpans: enableStandaloneClsSpans || false });\n\n      if (enableInp) {\n        startTrackingINP();\n      }\n\n      if (\n        enableLongAnimationFrame &&\n        GLOBAL_OBJ.PerformanceObserver &&\n        PerformanceObserver.supportedEntryTypes &&\n        PerformanceObserver.supportedEntryTypes.includes('long-animation-frame')\n      ) {\n        startTrackingLongAnimationFrames();\n      } else if (enableLongTask) {\n        startTrackingLongTasks();\n      }\n\n      if (enableInteractions) {\n        startTrackingInteractions();\n      }\n\n      function maybeEndActiveSpan(): void {\n        const activeSpan = getActiveIdleSpan(client);\n\n        if (activeSpan && !spanToJSON(activeSpan).timestamp) {\n          DEBUG_BUILD && logger.log(`[Tracing] Finishing current active span with op: ${spanToJSON(activeSpan).op}`);\n          // If there's an open active span, we need to finish it before creating an new one.\n          activeSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, 'cancelled');\n          activeSpan.end();\n        }\n      }\n\n      client.on('startNavigationSpan', startSpanOptions => {\n        if (getClient() !== client) {\n          return;\n        }\n\n        maybeEndActiveSpan();\n\n        getIsolationScope().setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });\n\n        const scope = getCurrentScope();\n        scope.setPropagationContext({ traceId: generateTraceId(), sampleRand: Math.random() });\n        // We reset this to ensure we do not have lingering incorrect data here\n        // places that call this hook may set this where appropriate - else, the URL at span sending time is used\n        scope.setSDKProcessingMetadata({\n          normalizedRequest: undefined,\n        });\n\n        _createRouteSpan(client, {\n          op: 'navigation',\n          ...startSpanOptions,\n        });\n      });\n\n      client.on('startPageLoadSpan', (startSpanOptions, traceOptions = {}) => {\n        if (getClient() !== client) {\n          return;\n        }\n        maybeEndActiveSpan();\n\n        const sentryTrace = traceOptions.sentryTrace || getMetaContent('sentry-trace');\n        const baggage = traceOptions.baggage || getMetaContent('baggage');\n\n        const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n\n        const scope = getCurrentScope();\n        scope.setPropagationContext(propagationContext);\n\n        // We store the normalized request data on the scope, so we get the request data at time of span creation\n        // otherwise, the URL etc. may already be of the following navigation, and we'd report the wrong URL\n        scope.setSDKProcessingMetadata({\n          normalizedRequest: getHttpRequestData(),\n        });\n\n        _createRouteSpan(client, {\n          op: 'pageload',\n          ...startSpanOptions,\n        });\n      });\n    },\n    afterAllSetup(client) {\n      let startingUrl: string | undefined = getLocationHref();\n\n      if (linkPreviousTrace !== 'off') {\n        linkTraces(client, { linkPreviousTrace, consistentTraceSampling });\n      }\n\n      if (WINDOW.location) {\n        if (instrumentPageLoad) {\n          const origin = browserPerformanceTimeOrigin();\n          startBrowserTracingPageLoadSpan(client, {\n            name: WINDOW.location.pathname,\n            // pageload should always start at timeOrigin (and needs to be in s, not ms)\n            startTime: origin ? origin / 1000 : undefined,\n            attributes: {\n              [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n              [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.browser',\n            },\n          });\n        }\n\n        if (instrumentNavigation) {\n          addHistoryInstrumentationHandler(({ to, from }) => {\n            /**\n             * This early return is there to account for some cases where a navigation transaction starts right after\n             * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't\n             * create an uneccessary navigation transaction.\n             *\n             * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also\n             * only be caused in certain development environments where the usage of a hot module reloader is causing\n             * errors.\n             */\n            if (from === undefined && startingUrl?.indexOf(to) !== -1) {\n              startingUrl = undefined;\n              return;\n            }\n\n            startingUrl = undefined;\n            const parsed = parseStringToURLObject(to);\n            startBrowserTracingNavigationSpan(client, {\n              name: parsed?.pathname || WINDOW.location.pathname,\n              attributes: {\n                [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n                [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.browser',\n              },\n            });\n\n            // We store the normalized request data on the scope, so we get the request data at time of span creation\n            // otherwise, the URL etc. may already be of the following navigation, and we'd report the wrong URL\n            getCurrentScope().setSDKProcessingMetadata({\n              normalizedRequest: {\n                ...getHttpRequestData(),\n                // Ensure to set this, so this matches the target route even if the URL has not yet been updated\n                url: to,\n              },\n            });\n          });\n        }\n      }\n\n      if (markBackgroundSpan) {\n        registerBackgroundTabDetection();\n      }\n\n      if (enableInteractions) {\n        registerInteractionListener(client, idleTimeout, finalTimeout, childSpanTimeout, latestRoute);\n      }\n\n      if (enableInp) {\n        registerInpInteractionListener();\n      }\n\n      instrumentOutgoingRequests(client, {\n        traceFetch,\n        traceXHR,\n        trackFetchStreamPerformance,\n        tracePropagationTargets: client.getOptions().tracePropagationTargets,\n        shouldCreateSpanForRequest,\n        enableHTTPTimings,\n        onRequestSpanStart,\n      });\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * Manually start a page load span.\n * This will only do something if a browser tracing integration integration has been setup.\n *\n * If you provide a custom `traceOptions` object, it will be used to continue the trace\n * instead of the default behavior, which is to look it up on the <meta> tags.\n */\nexport function startBrowserTracingPageLoadSpan(\n  client: Client,\n  spanOptions: StartSpanOptions,\n  traceOptions?: { sentryTrace?: string | undefined; baggage?: string | undefined },\n): Span | undefined {\n  client.emit('startPageLoadSpan', spanOptions, traceOptions);\n  getCurrentScope().setTransactionName(spanOptions.name);\n\n  return getActiveIdleSpan(client);\n}\n\n/**\n * Manually start a navigation span.\n * This will only do something if a browser tracing integration has been setup.\n */\nexport function startBrowserTracingNavigationSpan(client: Client, spanOptions: StartSpanOptions): Span | undefined {\n  client.emit('startNavigationSpan', spanOptions);\n\n  getCurrentScope().setTransactionName(spanOptions.name);\n\n  return getActiveIdleSpan(client);\n}\n\n/** Returns the value of a meta tag */\nexport function getMetaContent(metaName: string): string | undefined {\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document as (typeof WINDOW)['document'] | undefined;\n\n  const metaTag = optionalWindowDocument?.querySelector(`meta[name=${metaName}]`);\n  return metaTag?.getAttribute('content') || undefined;\n}\n\n/** Start listener for interaction transactions */\nfunction registerInteractionListener(\n  client: Client,\n  idleTimeout: BrowserTracingOptions['idleTimeout'],\n  finalTimeout: BrowserTracingOptions['finalTimeout'],\n  childSpanTimeout: BrowserTracingOptions['childSpanTimeout'],\n  latestRoute: RouteInfo,\n): void {\n  /**\n   * This is just a small wrapper that makes `document` optional.\n   * We want to be extra-safe and always check that this exists, to ensure weird environments do not blow up.\n   */\n  const optionalWindowDocument = WINDOW.document as (typeof WINDOW)['document'] | undefined;\n\n  let inflightInteractionSpan: Span | undefined;\n  const registerInteractionTransaction = (): void => {\n    const op = 'ui.action.click';\n\n    const activeIdleSpan = getActiveIdleSpan(client);\n    if (activeIdleSpan) {\n      const currentRootSpanOp = spanToJSON(activeIdleSpan).op;\n      if (['navigation', 'pageload'].includes(currentRootSpanOp as string)) {\n        DEBUG_BUILD &&\n          logger.warn(`[Tracing] Did not create ${op} span because a pageload or navigation span is in progress.`);\n        return undefined;\n      }\n    }\n\n    if (inflightInteractionSpan) {\n      inflightInteractionSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_IDLE_SPAN_FINISH_REASON, 'interactionInterrupted');\n      inflightInteractionSpan.end();\n      inflightInteractionSpan = undefined;\n    }\n\n    if (!latestRoute.name) {\n      DEBUG_BUILD && logger.warn(`[Tracing] Did not create ${op} transaction because _latestRouteName is missing.`);\n      return undefined;\n    }\n\n    inflightInteractionSpan = startIdleSpan(\n      {\n        name: latestRoute.name,\n        op,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: latestRoute.source || 'url',\n        },\n      },\n      {\n        idleTimeout,\n        finalTimeout,\n        childSpanTimeout,\n      },\n    );\n  };\n\n  if (optionalWindowDocument) {\n    addEventListener('click', registerInteractionTransaction, { once: false, capture: true });\n  }\n}\n\n// We store the active idle span on the client object, so we can access it from exported functions\nconst ACTIVE_IDLE_SPAN_PROPERTY = '_sentry_idleSpan';\nfunction getActiveIdleSpan(client: Client): Span | undefined {\n  return (client as { [ACTIVE_IDLE_SPAN_PROPERTY]?: Span })[ACTIVE_IDLE_SPAN_PROPERTY];\n}\n\nfunction setActiveIdleSpan(client: Client, span: Span | undefined): void {\n  addNonEnumerableProperty(client, ACTIVE_IDLE_SPAN_PROPERTY, span);\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1238, "column": 0}, "map": {"version":3,"file":"turbopack:///[project]/node_modules/@sentry/nextjs/build/esm/client/routing/appRouterRoutingInstrumentation.js","sources":["file:///home/ab/dev/grhog/GRHOG/node_modules/%40sentry/nextjs/src/client/routing/appRouterRoutingInstrumentation.ts"],"sourcesContent":["import type { Client, Span } from '@sentry/core';\nimport {\n  browserPerformanceTimeOrigin,\n  GLOBAL_OBJ,\n  SEMANTIC_ATTRIBUTE_SENTRY_OP,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n} from '@sentry/core';\nimport { startBrowserTracingNavigationSpan, startBrowserTracingPageLoadSpan, WINDOW } from '@sentry/react';\n\nexport const INCOMPLETE_APP_ROUTER_INSTRUMENTATION_TRANSACTION_NAME = 'incomplete-app-router-transaction';\n\n/**\n * This mutable keeps track of what router navigation instrumentation mechanism we are using.\n *\n * The default one is 'router-patch' which is a way of instrumenting that worked up until Next.js 15.3.0 was released.\n * For this method we took the global router instance and simply monkey patched all the router methods like push(), replace(), and so on.\n * This worked because Next.js itself called the router methods for things like the <Link /> component.\n * Vercel decided that it is not good to call these public API methods from within the framework so they switched to an internal system that completely bypasses our monkey patching. This happened in 15.3.0.\n *\n * We raised with Vercel that this breaks our SDK so together with them we came up with an API for `instrumentation-client.ts` called `onRouterTransitionStart` that is called whenever a navigation is kicked off.\n *\n * Now we have the problem of version compatibility.\n * For older Next.js versions we cannot use the new hook so we need to always patch the router.\n * For newer Next.js versions we cannot know whether the user actually registered our handler for the `onRouterTransitionStart` hook, so we need to wait until it was called at least once before switching the instrumentation mechanism.\n * The problem is, that the user may still have registered a hook and then call a patched router method.\n * First, the monkey patched router method will be called, starting a navigation span, then the hook will also called.\n * We need to handle this case and not create two separate navigation spans but instead update the current navigation span and then switch to the new instrumentation mode.\n * This is all denoted by this `navigationRoutingMode` variable.\n */\nlet navigationRoutingMode: 'router-patch' | 'transition-start-hook' = 'router-patch';\n\nconst currentRouterPatchingNavigationSpanRef: NavigationSpanRef = { current: undefined };\n\n/** Instruments the Next.js app router for pageloads. */\nexport function appRouterInstrumentPageLoad(client: Client): void {\n  const origin = browserPerformanceTimeOrigin();\n  startBrowserTracingPageLoadSpan(client, {\n    name: WINDOW.location.pathname,\n    // pageload should always start at timeOrigin (and needs to be in s, not ms)\n    startTime: origin ? origin / 1000 : undefined,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'pageload',\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.pageload.nextjs.app_router_instrumentation',\n      [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n    },\n  });\n}\n\ninterface NavigationSpanRef {\n  current: Span | undefined;\n}\n\ninterface NextRouter {\n  back: () => void;\n  forward: () => void;\n  push: (target: string) => void;\n  replace: (target: string) => void;\n}\n\n// Yes, yes, I know we shouldn't depend on these internals. But that's where we are at. We write the ugly code, so you don't have to.\nconst GLOBAL_OBJ_WITH_NEXT_ROUTER = GLOBAL_OBJ as typeof GLOBAL_OBJ & {\n  // Available until 13.4.4-canary.3 - https://github.com/vercel/next.js/pull/50210\n  nd?: {\n    router?: NextRouter;\n  };\n  // Available from 13.4.4-canary.4 - https://github.com/vercel/next.js/pull/50210\n  next?: {\n    router?: NextRouter;\n  };\n};\n\n/*\n * The routing instrumentation needs to handle a few cases:\n * - Router operations:\n *  - router.push() (either explicitly called or implicitly through <Link /> tags)\n *  - router.replace() (either explicitly called or implicitly through <Link replace /> tags)\n *  - router.back()\n *  - router.forward()\n * - Browser operations:\n *  - native Browser-back / popstate event (implicitly called by router.back())\n *  - native Browser-forward / popstate event (implicitly called by router.forward())\n */\n\n/** Instruments the Next.js app router for navigation. */\nexport function appRouterInstrumentNavigation(client: Client): void {\n  routerTransitionHandler = (href, navigationType) => {\n    const pathname = new URL(href, WINDOW.location.href).pathname;\n\n    if (navigationRoutingMode === 'router-patch') {\n      navigationRoutingMode = 'transition-start-hook';\n    }\n\n    const currentNavigationSpan = currentRouterPatchingNavigationSpanRef.current;\n    if (currentNavigationSpan) {\n      currentNavigationSpan.updateName(pathname);\n      currentNavigationSpan.setAttributes({\n        'navigation.type': `router.${navigationType}`,\n      });\n      currentRouterPatchingNavigationSpanRef.current = undefined;\n    } else {\n      startBrowserTracingNavigationSpan(client, {\n        name: pathname,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.nextjs.app_router_instrumentation',\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n          'navigation.type': `router.${navigationType}`,\n        },\n      });\n    }\n  };\n\n  WINDOW.addEventListener('popstate', () => {\n    if (currentRouterPatchingNavigationSpanRef.current?.isRecording()) {\n      currentRouterPatchingNavigationSpanRef.current.updateName(WINDOW.location.pathname);\n      currentRouterPatchingNavigationSpanRef.current.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, 'url');\n    } else {\n      currentRouterPatchingNavigationSpanRef.current = startBrowserTracingNavigationSpan(client, {\n        name: WINDOW.location.pathname,\n        attributes: {\n          [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.nextjs.app_router_instrumentation',\n          [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n          'navigation.type': 'browser.popstate',\n        },\n      });\n    }\n  });\n\n  let routerPatched = false;\n  let triesToFindRouter = 0;\n  const MAX_TRIES_TO_FIND_ROUTER = 500;\n  const ROUTER_AVAILABILITY_CHECK_INTERVAL_MS = 20;\n  const checkForRouterAvailabilityInterval = setInterval(() => {\n    triesToFindRouter++;\n    const router = GLOBAL_OBJ_WITH_NEXT_ROUTER?.next?.router ?? GLOBAL_OBJ_WITH_NEXT_ROUTER?.nd?.router;\n\n    if (routerPatched || triesToFindRouter > MAX_TRIES_TO_FIND_ROUTER) {\n      clearInterval(checkForRouterAvailabilityInterval);\n    } else if (router) {\n      clearInterval(checkForRouterAvailabilityInterval);\n      routerPatched = true;\n\n      patchRouter(client, router, currentRouterPatchingNavigationSpanRef);\n\n      // If the router at any point gets overridden - patch again\n      (['nd', 'next'] as const).forEach(globalValueName => {\n        const globalValue = GLOBAL_OBJ_WITH_NEXT_ROUTER[globalValueName];\n        if (globalValue) {\n          GLOBAL_OBJ_WITH_NEXT_ROUTER[globalValueName] = new Proxy(globalValue, {\n            set(target, p, newValue) {\n              if (p === 'router' && typeof newValue === 'object' && newValue !== null) {\n                patchRouter(client, newValue, currentRouterPatchingNavigationSpanRef);\n              }\n\n              // @ts-expect-error we cannot possibly type this\n              target[p] = newValue;\n              return true;\n            },\n          });\n        }\n      });\n    }\n  }, ROUTER_AVAILABILITY_CHECK_INTERVAL_MS);\n}\n\nfunction transactionNameifyRouterArgument(target: string): string {\n  try {\n    // We provide an arbitrary base because we only care about the pathname and it makes URL parsing more resilient.\n    return new URL(target, 'http://example.com/').pathname;\n  } catch {\n    return '/';\n  }\n}\n\nconst patchedRouters = new WeakSet<NextRouter>();\n\nfunction patchRouter(client: Client, router: NextRouter, currentNavigationSpanRef: NavigationSpanRef): void {\n  if (patchedRouters.has(router)) {\n    return;\n  }\n  patchedRouters.add(router);\n\n  (['back', 'forward', 'push', 'replace'] as const).forEach(routerFunctionName => {\n    if (router?.[routerFunctionName]) {\n      // @ts-expect-error Weird type error related to not knowing how to associate return values with the individual functions - we can just ignore\n      router[routerFunctionName] = new Proxy(router[routerFunctionName], {\n        apply(target, thisArg, argArray) {\n          if (navigationRoutingMode !== 'router-patch') {\n            return target.apply(thisArg, argArray);\n          }\n\n          let transactionName = INCOMPLETE_APP_ROUTER_INSTRUMENTATION_TRANSACTION_NAME;\n          const transactionAttributes: Record<string, string> = {\n            [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'navigation',\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.navigation.nextjs.app_router_instrumentation',\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'url',\n          };\n\n          if (routerFunctionName === 'push') {\n            transactionName = transactionNameifyRouterArgument(argArray[0]);\n            transactionAttributes['navigation.type'] = 'router.push';\n          } else if (routerFunctionName === 'replace') {\n            transactionName = transactionNameifyRouterArgument(argArray[0]);\n            transactionAttributes['navigation.type'] = 'router.replace';\n          } else if (routerFunctionName === 'back') {\n            transactionAttributes['navigation.type'] = 'router.back';\n          } else if (routerFunctionName === 'forward') {\n            transactionAttributes['navigation.type'] = 'router.forward';\n          }\n\n          currentNavigationSpanRef.current = startBrowserTracingNavigationSpan(client, {\n            name: transactionName,\n            attributes: transactionAttributes,\n          });\n\n          return target.apply(thisArg, argArray);\n        },\n      });\n    }\n  });\n}\n\nlet routerTransitionHandler: undefined | ((href: string, navigationType: string) => void) = undefined;\n\n/**\n * A handler for Next.js' `onRouterTransitionStart` hook in `instrumentation-client.ts` to record navigation spans in Sentry.\n */\nexport function captureRouterTransitionStart(href: string, navigationType: string): void {\n  if (routerTransitionHandler) {\n    routerTransitionHandler(href, navigationType);\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}